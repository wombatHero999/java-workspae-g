package com.kh.chap02_abstract.part02.model.vo;

public interface Basic {
	/* 
	 * 인터페이스
	 *  - 상수필드와 추상메서드만 사용 가능한 추상클래스의 변형체(jdk7 이전)
	 *  - 인터페이스에서 필드는 무조건 "상수필드"이며, 메서드는 무조건 "추상메서드"
	 *  - 특정클래스에서 무조건 구현해야하는 기능이 존재하는 경우 인터페이스를 만들어 상속시킨다.
	 *  - 인터페이스는 다중 상속을 허용한다. 
	 *    (인터페이스들은 결국 메서드의 이름,반환형,매개변수만 정의하고 있으므로 최종 구현 부분은 인터페이스를 상속받은
	 *    클래스에서 딱 한번만 이루어지므로 다중상속이 가능)
	 *  - 추상클래스와 다르게 강한 규칙성으로 통일된 인터페이스를 갖추게 할 때 사용
	 * 
	 * 추상클래스와 인터페이스.
	 *  1. 공통점
	 *   - 객체 생성은 안되나, 참조변수로서 사용 가능
	 *   - 인터페이스 및 추상클래스를 상속받는 클래스에서는 추상메서드를 강제로 구현해야한다.
	 *   
	 *  2. 차이점
	 *   - 추상클래스에서는 인스턴스 변수(필드) 및 일반 메서드를 생성할 수 있지만, 인터페이스는
	 *   오직 상수필드와 추상메서드만 사용 가능하다.
	 *   - 사용하는 목적이 다르다
	 *   
	 *   추상클래스는 클래스들이 가지는 공통 속성과, 기능을 자식클래스에게 상속시키면서 특정 기능 구현을
	 *   강제하고자 할때 사용하기 때문에 "상속"이 주 목적이고, "강제기능구현"은 부가적인 목적이다.
	 *   
	 *   인터페이스는 클래스의 기능 구현을 "약속"하기 위해 사용한다. 인터페이스를 구현한 모든 클래스는
	 *   "동일한 동작"을 보장할 수 있다. 일관된 동작을 보장하기위해 사용한다. 
	 *   
	 *   인터페이스의 상속(implements)
	 *    - 클래스와 클래스의 상속 관계 : 클래스명 extends 부모클래스
	 *    - 클래스와 인터페이스의 상속 관계 : 클래스명 implements 인터페이스명 [, 인터페이스, 인터페이스] 
	 *    - 인터페이스와 인터페이스의 상속 관계 : 인터페이스명 extends 인터페이스명 [, 인터페이스명]
	 * */	
	
	// 인터페이스 내부에서는 상수필드(public final static)만 정의 가능.
	// 따라서 , 상수필드예약어를 생략해도 항상 자동으로 추가되어 있다.
	/* public static final */ int num = 10;
	
	// 인터페이스 내부에서는 추상메서드만 정의할 수 있다.
	// 기본 메서드는 항상 추상메서드로 간주하기 때문에 public abstract 생략가능
	/* public abstract */ void eat();
	
	
	// jdk8버전 이후 
	// 인터페이스 내부에서 디폴트 메서드를 사용 할 수 있다.
	
	// 인터페이스를 구현하는 모든 하위클래스에서 공통된 기능이 존재하는 경우 사용
	default void breathing() {
		System.out.println("숨 쉬기");
	}
	
	// 정적메서드는 사용 가능.
	// 상수필드와 동일하게 "객체 생성 없이" 접근 가능한 메서드이므로 인터페이스에서도 작성할 수 있다.
	static void thinking() {
		System.out.println("생각하기");
	}
}














